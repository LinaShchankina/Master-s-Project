/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar myVertexShader = \"\\n    precision highp float;\\n    \\n    /* \\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD \\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD, \\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD \\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD (\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD x,y,z) */\\n    attribute vec3 a_VertexPosition;\\n    attribute vec3 a_Normals;\\n    attribute mat3 a_TextureCoords;\\n    attribute vec2 a_localNumbers;\\n    \\n    /* \\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD \\uFFFD\\uFFFD\\uFFFD \\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD \\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD */\\n    varying vec3 v_Normals;\\n    varying mat3 v_TextureCoords;\\n    varying vec4 v_localNumbers;\\n    \\n    \\n    /* \\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD \\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD \\uFFFD\\uFFFD\\uFFFD \\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD */\\n    uniform mat4 uMVMatrix; /* \\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD \\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD */\\n    uniform mat4 uPMatrix; /* \\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD \\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD */\\n    \\n    void main(void) {\\n    \\n        float y1 = 0.;\\n        float y2 = 1.;\\n        float y3 = 0.;\\n        float x1 = 1.;\\n        float x2 = 0.;\\n        float x3 = 0.;\\n    \\n        float x = x1 * a_localNumbers[0] x2 * a_localNumbers[1] x3 * (1. - a_localNumbers[0] - a_localNumbers[1]);\\n        float y = y1 * a_localNumbers[0] y2 * a_localNumbers[1] y3 * (1. - a_localNumbers[0] - a_localNumbers[1]);\\n    \\n        /* \\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD \\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD \\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD \\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD */\\n        gl_Position = uPMatrix * uMVMatrix * vec4(a_VertexPosition, 1.0);\\n        v_localNumbers = vec4(x, y, 0.0, 1.0);\\n        v_Normals = a_Normals;\\n        v_TextureCoords = a_TextureCoords;\\n    }\";\r\nvar myFragmentShader1 = \"\\n    #extension GL_EXT_draw_buffers : require\\n\\n    /* \\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD \\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD \\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD \\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD, \\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD \\uFFFD\\uFFFD \\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD \\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD, float (-2\\uFFFD14,2\\uFFFD14) */\\n    precision highp float;\\n\\n    varying vec3 v_Normals;\\n    varying vec4 v_localNumbers;\\n    varying mat3 v_TextureCoords;\\n\\n    void main(void) {\\n\\n        float y1 = 0.;\\n        float y2 = 1.;\\n        float y3 = 0.;\\n        float x1 = 1.;\\n        float x2 = 0.;\\n        float x3 = 0.;\\n\\n        float a = y3 - y2;  //y3-y2\\n        float b = y3 - y1;  //y3-y1\\n        float c = y2 - y1;  //y2-y1\\n\\n        float d = x3 - x2;  //x3-x2\\n        float e = x3 - x1;\\t//x3-x1\\n        float f = x2 - x1;\\t//x2-x1\\n\\n        float u = 0.;\\n        float detD = abs(f * b - e * c);\\n\\n        /*float x = x1 * v_localNumbers[0] x2 * v_localNumbers[1] x3 * (1. - v_localNumbers[0] - v_localNumbers[1]);\\n        float y = y1 * v_localNumbers[0] y2 * v_localNumbers[1] y3 * (1. - v_localNumbers[0] - v_localNumbers[1]);*/\\n\\n        vec3 L = vec3(abs(d*(v_localNumbers[1] - y2) - a * (v_localNumbers[0] - x2))/detD,\\n        abs(b*(v_localNumbers[0] - x3) - e * (v_localNumbers[1] - y3))/detD,\\n        abs(f*(v_localNumbers[1] - y1) - c * (v_localNumbers[0] - x1))/detD);\\n\\n        mat3 phi = mat3(vec3(L[0] * (2. * L[0] - 1.), L[1] * (2. * L[1] - 1.), L[2] * (2. * L[2] - 1.)),\\n        vec3( 4. * L[0] * L[1], 4. * L[1] * L[2], 4. * L[0] * L[2]),\\n        vec3( 0., 0., 0.));\\n\\n        for (int i = 0; i < 3; i++)\\n        for(int j = 0; j < 3; j++)\\n        u= v_TextureCoords[j][i] * phi[j][i];\\n\\n        gl_FragData[0] = vec4(u, u, u, 1);\\n        gl_FragData[1] = vec4(0.5 * (vec3(1, 1, 1) v_Normals), 1);\\n        }\";\r\nvar myFragmentShader2 = \"\\n    precision highp float;\\n\\n    /* sampler1D - \\uFFFD\\uFFFD\\uFFFD \\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD \\uFFFD\\uFFFD\\uFFFD 2D \\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD */\\n    uniform sampler2D normal_Sampler;\\n    uniform sampler2D color_Sampler;\\n    uniform sampler2D grad_Sampler;\\n\\n    uniform vec2 canvasSize;\\n    uniform int countOfLines;\\n    uniform int thickness;\\n\\n    void main(void) {\\n        vec2 pos = vec2(gl_FragCoord.x / canvasSize.x, gl_FragCoord.y / canvasSize.y);\\n\\n        float xInt = 1.0 / canvasSize.x;\\n        float yInt = 1.0 / canvasSize.y;\\n\\n        float thickness = float(thickness);\\n        float count = float(countOfLines + 1);\\n        /* \\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD \\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD \\uFFFD\\uFFFD\\uFFFD\\uFFFD \\uFFFD \\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD */\\n\\n        vec2 thisPix = pos;\\n        vec2 befPix = vec2(pos.x - thickness*xInt, pos.y);\\n        vec2 nextPix = vec2(pos.x + thickness*xInt, pos.y);\\n        vec2 upPix = vec2(pos.x, pos.y + thickness*yInt);\\n        vec2 downPix = vec2(pos.x, pos.y - thickness*yInt);\\n        vec2 befUpPix = vec2(pos.x - thickness*xInt, pos.y + thickness*yInt);\\n        vec2 befDownPix = vec2(pos.x - thickness*xInt, pos.y - thickness*yInt);\\n        vec2 nextUpPix = vec2(pos.x + thickness*xInt, pos.y + thickness*yInt);\\n        vec2 nextDownPix = vec2(pos.x + thickness*xInt, pos.y - thickness*yInt);\\n\\n        vec4 thisCol = texture2D(normal_Sampler, thisPix);\\n        vec4 befCol = texture2D(normal_Sampler, befPix);\\n        vec4 nextCol = texture2D(normal_Sampler, nextPix);\\n        vec4 upCol = texture2D(normal_Sampler, upPix);\\n        vec4 downCol = texture2D(normal_Sampler, downPix);\\n        vec4 befUpCol = texture2D(normal_Sampler, befUpPix);\\n        vec4 befDownCol = texture2D(normal_Sampler, befDownPix);\\n        vec4 nextUpCol = texture2D(normal_Sampler, nextUpPix);\\n        vec4 nextDownCol = texture2D(normal_Sampler, nextDownPix);\\n\\n        vec4 thisCol2 = texture2D(color_Sampler, thisPix);\\n        vec4 befCol2 = texture2D(color_Sampler, befPix);\\n        vec4 nextCol2 = texture2D(color_Sampler, nextPix);\\n        vec4 upCol2 = texture2D(color_Sampler, upPix);\\n        vec4 downCol2 = texture2D(color_Sampler, downPix);\\n        vec4 befUpCol2 = texture2D(color_Sampler, befUpPix);\\n        vec4 befDownCol2 = texture2D(color_Sampler, befDownPix);\\n        vec4 nextUpCol2 = texture2D(color_Sampler, nextUpPix);\\n        vec4 nextDownCol2 = texture2D(color_Sampler, nextDownPix);\\n\\n        float befDif = dot(thisCol - befCol, thisCol - befCol);\\n        float nextDif = dot(thisCol - nextCol, thisCol - nextCol);\\n        float upDif = dot(thisCol - upCol, thisCol - upCol);\\n        float downDif = dot(thisCol - downCol, thisCol - downCol);\\n        float befUpDif = dot(thisCol - befUpCol, thisCol - befUpCol);\\n        float befDownDif = dot(thisCol - befDownCol, thisCol - befDownCol);\\n        float nextUpDif = dot(thisCol - nextUpCol, thisCol - nextUpCol);\\n        float nextDownDif = dot(thisCol - nextDownCol, thisCol - nextDownCol);\\n\\n        float delta = 0.1;\\n        float delta2 = 1.0;\\n\\n        float u = 1.0 - thisCol2.r;\\n\\n        /* \\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD \\uFFFD\\uFFFD \\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD \\uFFFD \\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD */\\n        if(befDif > delta)\\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\\n        else {\\n            if(nextDif > delta)\\n                gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\\n            else {\\n                if(upDif > delta)\\n                    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\\n                else {\\n                    if(downDif > delta)\\n                        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\\n                    else {\\n                        if(befUpDif > delta)\\n                            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\\n                        else {\\n                            if(befDownDif > delta)\\n                                gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\\n                            else {\\n                                if(nextUpDif > delta)\\n                                    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\\n                                else {\\n                                    if(nextDownDif > delta)\\n                                        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\\n                                    else {\\n                                        /*float left = floor(befCol2.r * count);\\n                                        float right = floor(nextCol2.r * count);\\n                                        float diffGor = abs(left - right);\\n\\n                                        float down = floor(downCol2.r * count);\\n                                        float up = floor(upCol2.r * count);\\n                                        float diffVert = abs(up - down);\\n\\n                                        float befUp = floor(befUpCol2.r * count);\\n                                        float nextDown = floor(nextDownCol2.r * count);\\n                                        float diffUbiv = abs(befUp - nextDown);\\n\\n                                        float befDown = floor(befDownCol2.r * count);\\n                                        float nextUp = floor(nextUpCol2.r * count);\\n                                        float diffVozr = abs(befDown - nextUp);\\n\\n                                        if(diffGor < delta2 && diffVert < delta2 && diffUbiv < delta2 && diffVozr < delta2)*/\\n                                        gl_FragColor = texture2D(grad_Sampler, vec2(u, 0.0));\\n                                        /*else\\n                                        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);*/\\n                                    }\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n}\";\r\nvar myFragmentShader3 = \"\\n    void main(void) {\\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\\n    }\";\r\n// const gl;\r\n// var size;\r\n// var shaderProgram;\r\n// var shaderProgram2;\r\n// var shaderProgram3;\r\n// /* ���������� ���������� ������� ������ � ������� �������� */\r\n// var mvMatrix = mat4.create();\r\n// var pMatrix = mat4.create();\r\n// var triangleVertexValueBuffer;\r\n// var normalsBuffer;\r\n// var pass;\r\n// var ext; var ext2;\r\n// var fb;\r\n// var colorTexture;\r\n// var normalTexture;\r\n// var tmp = 0;\r\nvar canvas;\r\n// var currentAngle;\r\n// var ln = 3;\r\n// var thick = 1;\r\n// // ������ ����� ��� ����������\r\n// var points = [];\r\n// // ������ ������������\r\n// var triangles = [];\r\n// var pointsBuffer;\r\nfunction InitGL() {\r\n    /* �������� �������� ����������� �������� webgl */\r\n    var gl = canvas.getContext(\"webgl\");\r\n    if (!gl) {\r\n        alert(\"ERROR:could not initialise WebGL!\");\r\n        return null;\r\n    }\r\n    return gl;\r\n}\r\n// function findValueInPoint(point : any, values : any){\r\n//     let y1 = 0.;\r\n//     let y2 = 1.;\r\n//     let y3 = 0.;\r\n//     let x1 = 1.;\r\n//     let x2 = 0.;\r\n//     let x3 = 0.;\r\n//     let a = y3 - y2;  //y3-y2\r\n//     let b = y3 - y1;  //y3-y1\r\n//     let c = y2 - y1;  //y2-y1\r\n//     let d = x3 - x2;  //x3-x2\r\n//     let e = x3 - x1;\t//x3-x1\r\n//     let f = x2 - x1;\t//x2-x1\r\n//     let u = 0.;\r\n//     let detD = Math.abs(f * b - e * c);\r\n//     let x = x1 * point[0] + x2 * point[1] + x3 * (1. - point[0] - point[1]);\r\n//     let y = y1 * point[0] + y2 * point[1] + y3 * (1. - point[0] - point[1]);\r\n//     let L = [\r\n//         Math.abs(d*(point[1] - y2) - a * (point[0] - x2))/detD,\r\n//         Math.abs(b*(point[0] - x3) - e * (point[1] - y3))/detD,\r\n//         Math.abs(f*(point[1] - y1) - c * (point[0] - x1))/detD\r\n//     ];\r\n//     let phi = [\r\n//         [L[0] * (2. * L[0] - 1.), L[1] * (2. * L[1] - 1.), L[2] * (2. * L[2] - 1.)],\r\n//         [4. * L[0] * L[1], 4. * L[1] * L[2], 4. * L[0] * L[2]],\r\n//         [0., 0., 0.]\r\n//     ];\r\n//     for (let i = 0; i < 3; i++)\r\n//         for(let j = 0; j < 3; j++)\r\n//             u += values[j][i] * phi[j][i];\r\n//     return u;\r\n// }\r\n// function findEqualValue(triangle : any){\r\n//     if(ln == 0) return;\r\n//     let a = triangle.a;\r\n//     let b = triangle.b;\r\n//     let c = triangle.c;\r\n//     let values = triangle.values;\r\n//     let abLocal = (t) => {\r\n//         return [\r\n//         a.localNumber[0] + (b.localNumber[0] - a.localNumber[0])*t,\r\n//         a.localNumber[1] + (b.localNumber[1] - a.localNumber[1])*t\r\n//         ]\r\n//     };\r\n//     let abGlobal = (t) => {\r\n//         return {\r\n//             x:a.x + (b.x -a.x)*t,\r\n//             y:a.y + (b.y -a.y)*t,\r\n//             z:a.z + (b.z -a.z)*t\r\n//         }\r\n//     };\r\n//     let bcLocal = (t) => {\r\n//         return [\r\n//         b.localNumber[0] + (c.localNumber[0] - b.localNumber[0])*t,\r\n//         b.localNumber[1] + (c.localNumber[1] - b.localNumber[1])*t\r\n//         ]\r\n//     };\r\n//     let bcGlobal = (t) => {\r\n//         return {\r\n//             x:b.x + (c.x - b.x)*t,\r\n//             y:b.y + (c.y - b.y)*t,\r\n//             z:b.z + (c.z - b.z)*t\r\n//         }\r\n//     };\r\n//     let caLocal = (t) => {\r\n//         return [\r\n//         c.localNumber[0] + (a.localNumber[0] - c.localNumber[0])*t,\r\n//         c.localNumber[1] + (a.localNumber[1] - c.localNumber[1])*t\r\n//         ]\r\n//     };\r\n//     let caGlobal = (t) => {\r\n//         return {\r\n//             x:c.x + (a.x - c.x)*t,\r\n//             y:c.y + (a.y - c.y)*t,\r\n//             z:c.z + (a.z - c.z)*t\r\n//         }\r\n//     };\r\n//     let abLength = Math.sqrt((b.localNumber[0] - a.localNumber[0])*(b.localNumber[0] - a.localNumber[0]) + (b.localNumber[1] - a.localNumber[1])*(b.localNumber[1] - a.localNumber[1]) );\r\n//     let bcLength = Math.sqrt((c.localNumber[0] - b.localNumber[0])*(c.localNumber[0] - b.localNumber[0]) + (c.localNumber[1] - b.localNumber[1])*(c.localNumber[1] - b.localNumber[1]) );\r\n//     let caLength = Math.sqrt((a.localNumber[0] - c.localNumber[0])*(a.localNumber[0] - c.localNumber[0]) + (a.localNumber[1] - c.localNumber[1])*(a.localNumber[1] - c.localNumber[1]) );\r\n//     let count = 50;\r\n//     let aEps = abLength / (count);\r\n//     let bEps = bcLength / (count);\r\n//     let cEps = caLength / (count);\r\n//     let eps = 0.001;\r\n//     for(let ai = 1; ai < count + 1; ai++) {\r\n//         let aCoord = abLocal(ai*aEps);\r\n//         var aValue = findValueInPoint(aCoord, values);\r\n//         for(let bi = 1; bi < count + 1; bi++) {\r\n//             let bCoord = bcLocal(bi*bEps);\r\n//             var bValue = findValueInPoint(bCoord, values);\r\n//             if (Math.abs(aValue - bValue) < eps) {\r\n//                 points.push(abGlobal(ai*aEps).x.toFixed(3));\r\n//                 points.push(abGlobal(ai*aEps).y.toFixed(3));\r\n//                 points.push(abGlobal(ai*aEps).z.toFixed(3));\r\n//                 points.push(bcGlobal(bi*bEps).x.toFixed(3));\r\n//                 points.push(bcGlobal(bi*bEps).y.toFixed(3));\r\n//                 points.push(bcGlobal(bi*bEps).z.toFixed(3));\r\n//             }\r\n//             for(let ci = 1; ci < count + 1; ci++) {\r\n//                 let cCoord = caLocal(ci*cEps);\r\n//                 var cValue = findValueInPoint(cCoord, values);\r\n//                 if (Math.abs(aValue - cValue) < eps) {\r\n//                     points.push(abGlobal(ai*aEps).x.toFixed(3));\r\n//                     points.push(abGlobal(ai*aEps).y.toFixed(3));\r\n//                     points.push(abGlobal(ai*aEps).z.toFixed(3));\r\n//                     points.push(caGlobal(ci*cEps).x.toFixed(3));\r\n//                     points.push(caGlobal(ci*cEps).y.toFixed(3));\r\n//                     points.push(caGlobal(ci*cEps).z.toFixed(3));\r\n//                 }\r\n//                 if (Math.abs(bValue - cValue) < eps) {\r\n//                     points.push(bcGlobal(bi*bEps).x.toFixed(3));\r\n//                     points.push(bcGlobal(bi*bEps).y.toFixed(3));\r\n//                     points.push(bcGlobal(bi*bEps).z.toFixed(3));\r\n//                     points.push(caGlobal(ci*cEps).x.toFixed(3));\r\n//                     points.push(caGlobal(ci*cEps).y.toFixed(3));\r\n//                     points.push(caGlobal(ci*cEps).z.toFixed(3));\r\n//                 }\r\n//             }\r\n//         }\r\n//     }\r\n// }\r\n// function parseInTriangles(vertval){\r\n//     for(let i = 0; i < vertval.length; i += 42)\r\n//         triangles.push(\r\n//             {\r\n//                 a:{ x:vertval[i], y:vertval[i+1], z:vertval[i+2], localNumber:[vertval[i+12], vertval[i+13]]},\r\n//                 b:{ x:vertval[i+14], y:vertval[i+15], z:vertval[i+16], localNumber:[vertval[i+26], vertval[i+27]]},\r\n//                 c:{ x:vertval[i+28], y:vertval[i+29], z:vertval[i+30], localNumber:[vertval[i+40], vertval[i+41]]},\r\n//                 values:[\r\n//                     [vertval[i+3], vertval[i+4], vertval[i+5]],\r\n//                     [vertval[i+6], vertval[i+7], vertval[i+8]],\r\n//                     [vertval[i+9], vertval[i+10], vertval[i+11]]\r\n//                 ]\r\n//             }\r\n//         );\r\n//     triangles.forEach((triangle) => {\r\n//         findEqualValue(triangle);\r\n//     });\r\n// }\r\n// function getShader(gl, type, str) {\r\n//     /* �������� �������� */\r\n//     const shader = gl.createShader(type);\r\n//     /* ���������� ��������� ���� ������� */\r\n//     gl.shaderSource(shader, str);\r\n//     /* ���������� ������� */\r\n//     gl.compileShader(shader);\r\n//     /* �������� �� ��������� ���������� ������� */\r\n//     if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n//         alert(\"ERROR\" + gl.getShaderInfoLog(shader));\r\n//         gl.deleteShader(shader);\r\n//         return null;\r\n//     }\r\n//     return shader;\r\n// }\r\nvar ValuesParser = /** @class */ (function () {\r\n    function ValuesParser() {\r\n        this.max = 0;\r\n        this.min = 0;\r\n    }\r\n    ValuesParser.prototype.init = function (max, min) {\r\n        this.max = max;\r\n        this.min = min;\r\n    };\r\n    ValuesParser.prototype.parse = function (str) {\r\n        return (parseFloat(str) - this.min) / (this.max - this.min);\r\n    };\r\n    return ValuesParser;\r\n}());\r\nvar Model = /** @class */ (function () {\r\n    function Model() {\r\n        this.minSolution = 0;\r\n        this.maxSolution = 0;\r\n        this.countOfTriangles = 0;\r\n        this.triangles = new Array();\r\n    }\r\n    ;\r\n    return Model;\r\n}());\r\nvar Triangle = /** @class */ (function () {\r\n    function Triangle() {\r\n        this.weight = new Array(6);\r\n        this.globalCoords = new Array(3);\r\n        this.localCoords = new Array(3);\r\n        this.normals = new Array(3);\r\n    }\r\n    ;\r\n    return Triangle;\r\n}());\r\nfunction ReadTXTFile(fileContent, model) {\r\n    /* ��������� ������ �� ��������, ������������ ������ ������ �������� ������ \\n � ������ */\r\n    var array = fileContent && fileContent.split(' ');\r\n    model.countOfTriangles = parseInt(array[0]);\r\n    var j = 1 + 6 * model.countOfTriangles;\r\n    var k = 0;\r\n    var p = 1;\r\n    var ii = 0;\r\n    var v = 1 + 6 * model.countOfTriangles + 3 * 3 * model.countOfTriangles;\r\n    var tex = [];\r\n    var min = parseFloat(array[1]);\r\n    var max = min;\r\n    for (var i = 2; i < model.countOfTriangles * 6 + 1; i++) {\r\n        if (parseFloat(array[i]) > max)\r\n            max = parseFloat(array[i]);\r\n        if (parseFloat(array[i]) < min)\r\n            min = parseFloat(array[i]);\r\n    }\r\n    var valuesParser = new ValuesParser();\r\n    valuesParser.init(max, min);\r\n    model.triangles.forEach(function (triangle) {\r\n        triangle.globalCoords.forEach(function (x) {\r\n            x = parseFloat(array[j]);\r\n            j++;\r\n        });\r\n        triangle.weight.forEach(function (x) {\r\n            x = parseFloat(array[p]);\r\n            p++;\r\n        });\r\n        for (var k = 0; k < triangle.localCoords.length; k++) {\r\n            switch (k % 3) {\r\n                case 0:\r\n                    triangle.localCoords[k] = [1., 0.];\r\n                    break;\r\n                case 1:\r\n                    triangle.localCoords[k] = [0., 1.];\r\n                    break;\r\n                case 2:\r\n                    triangle.localCoords[k] = [0., 0.];\r\n                    break;\r\n            }\r\n        }\r\n        triangle.normals.forEach(function (x) {\r\n            x = parseFloat(array[v]);\r\n            v++;\r\n        });\r\n    });\r\n    // for (var i = 0; i < model.countOfTriangles; i++) {\r\n    //     model.triangles[i].globalCoords.forEach((x)=>{\r\n    //         x = parseFloat(array[j]);\r\n    //         j++;\r\n    //     });\r\n    //     model.triangles[i].weight.forEach((x)=>{\r\n    //         x = parseFloat(array[p]);\r\n    //         p++;\r\n    //     });\r\n    //     for (var k = 0; k < model.triangles[i].localCoords.length; k++) \r\n    //     {\r\n    //         switch (k % 3)\r\n    //         {\r\n    //             case 0: \r\n    //                 model.triangles[i].localCoords[k] = [1., 0.];\r\n    //                 break;\r\n    //             case 1: \r\n    //                 model.triangles[i].localCoords[k] = [0., 1.];\r\n    //                 break;\r\n    //             case 2: \r\n    //                 model.triangles[i].localCoords[k] = [0., 0.];\r\n    //                 break;\r\n    //         }           \r\n    //     }\r\n    //     model.triangles[i].normals.forEach((x)=>{\r\n    //         x = parseFloat(array[v]);\r\n    //         v++;\r\n    //     });\r\n    /* vertval[k] = parseFloat(array[j]);\r\n     vertval[k + 1] = parseFloat(array[j + 1]);\r\n     vertval[k + 2] = parseFloat(array[j + 2]);\r\n\r\n     vertval[k + 3] = valuesParser.parse(array[p]);//parseFloat(array[p]);\r\n     vertval[k + 4] = valuesParser.parse(array[p + 1]);//parseFloat(array[p + 1]);\r\n     vertval[k + 5] = valuesParser.parse(array[p + 2]);//parseFloat(array[p + 2]);\r\n     vertval[k + 6] = valuesParser.parse(array[p + 3]);//parseFloat(array[p + 3]);\r\n     vertval[k + 7] = valuesParser.parse(array[p + 4]);//parseFloat(array[p + 4]);\r\n     vertval[k + 8] = valuesParser.parse(array[p + 5]);//parseFloat(array[p + 5]);\r\n     vertval[k + 9] = 0.0;\r\n     vertval[k + 10] = 0.0;\r\n     vertval[k + 11] = 0.0;\r\n\r\n     if (i % 3 == 0) {\r\n         vertval[k + 12] = 1.;\r\n         vertval[k + 13] = 0.;\r\n     }\r\n     if (i % 3 == 1) {\r\n         vertval[k + 12] = 0.;\r\n         vertval[k + 13] = 1.;\r\n     }\r\n     if (i % 3 == 2) {\r\n         vertval[k + 12] = 0.;\r\n         vertval[k + 13] = 0.;\r\n     }\r\n\r\n     normals[ii] = parseInt(array[v]);\r\n     normals[ii + 1] = parseInt(array[v + 1]);\r\n     normals[ii + 2] = parseInt(array[v + 2]);\r\n     ii += 3;\r\n     k += 14;\r\n     j += 3;\r\n     if (i % 3 == 2) {\r\n         p += 6;\r\n         v += 3;\r\n     }\r\n }*/\r\n}\r\nfunction ReadSTLFile(fileContent, model) {\r\n    // let geom = stl.LoadSTL(fileContent, model.countOfTriangles);\r\n    // var k = 0;\r\n    // var p = 0;\r\n    // for (var j = 0; j < model.countOfTriangles * 3; j++) {\r\n    //     vertval[k] = geom.vertices[j][\"x\"];\r\n    //     vertval[k + 1] = geom.vertices[j][\"y\"];\r\n    //     vertval[k + 2] = geom.vertices[j][\"z\"];\r\n    //     /* ������� = x */\r\n    //     var x1 = geom.vertices[p][\"x\"];\r\n    //     var x2 = geom.vertices[p + 1][\"x\"];\r\n    //     var x3 = geom.vertices[p + 2][\"x\"];\r\n    //     var y1 = geom.vertices[p][\"y\"];\r\n    //     var y2 = geom.vertices[p + 1][\"y\"];\r\n    //     var y3 = geom.vertices[p + 2][\"y\"];\r\n    //     var z1 = geom.vertices[p][\"z\"];\r\n    //     var z2 = geom.vertices[p + 1][\"z\"];\r\n    //     var z3 = geom.vertices[p + 2][\"z\"];\r\n    //     vertval[k + 3] = x1*x1 - 2*y1;\r\n    //     vertval[k + 4] = x2*x2 - 2*y2;\r\n    //     vertval[k + 5] = x3*x3 - 2*y3;\r\n    //     vertval[k + 6] = (x1 + x2) / 2 * (x1 + x2) / 2 - 2 * ((y1 + y2) / 2) ;\r\n    //     vertval[k + 7] = (x2 + x3) / 2 * (x2 + x3) / 2 - 2 * ((y2 + y3) / 2) ;\r\n    //     vertval[k + 8] = (x1 + x3) / 2 * (x1 + x3) / 2 - 2 * ((y1 + y3) / 2) ;\r\n    //     vertval[k + 9] = 0.0;\r\n    //     vertval[k + 10] = 0.0;\r\n    //     vertval[k + 11] = 0.0;\r\n    //     if (j % 3 == 0) {\r\n    //         vertval[k + 12] = 1.;\r\n    //         vertval[k + 13] = 0.;\r\n    //     }\r\n    //     if (j % 3 == 1) {\r\n    //         vertval[k + 12] = 0.;\r\n    //         vertval[k + 13] = 1.;\r\n    //     }\r\n    //     if (j % 3 == 2) {\r\n    //         vertval[k + 12] = 0.;\r\n    //         vertval[k + 13] = 0.;\r\n    //     }\r\n    //     k += 14;\r\n    //     if (j % 3 == 2) p += 3;\r\n    // }\r\n    // var min = vertval[3];\r\n    // var max = min;\r\n    // for (var i = 3; i < size * 3 * 14; i += 14)\r\n    //     for (var k = 0; k < 6; k++) {\r\n    //         if (vertval[i + k] > max) max = vertval[i + k];\r\n    //         if (vertval[i + k] < min) min = vertval[i + k];\r\n    //     }\r\n    // for (var i = 3; i < size * 3 * 14; i += 14)\r\n    //     for (var k = 0; k < 6; k++)\r\n    //         vertval[i + k] =  (vertval[i + k] - min) / (max - min);\r\n    // for (var i = 0; i < size; i++)\r\n    // {\r\n    //     var face = geom.faces[i];\r\n    //     normals[face[\"a\"]*3] = face[\"normal\"][\"x\"];\r\n    //     normals[face[\"a\"]*3+1] = face[\"normal\"][\"y\"];\r\n    //     normals[face[\"a\"]*3+2] = face[\"normal\"][\"z\"];\r\n    //     normals[face[\"b\"]*3] = face[\"normal\"][\"x\"];\r\n    //     normals[face[\"b\"]*3+1] = face[\"normal\"][\"y\"];\r\n    //     normals[face[\"b\"]*3+2] = face[\"normal\"][\"z\"];\r\n    //     normals[face[\"c\"]*3] = face[\"normal\"][\"x\"];\r\n    //     normals[face[\"c\"]*3+1] = face[\"normal\"][\"y\"];\r\n    //     normals[face[\"c\"]*3+2] = face[\"normal\"][\"z\"];\r\n    // }\r\n}\r\nfunction InputData(callback, model) {\r\n    /* ���������, ������������ �� ������� ������ API */\r\n    if (!window.File || !window.FileReader || !window.FileList || !window.Blob) {\r\n        alert('ERROR: file API is not supported!');\r\n        return;\r\n    }\r\n    var inputElement = document.getElementById('file');\r\n    inputElement.onchange = function (e) {\r\n        /* ���������� � ����� (! ��������, ��� ����� �� null) */\r\n        var file = e.target.files[0];\r\n        /* ��� ������������ ��������� ���� � ������� ������ ��� ������ ��� ������� ������ */\r\n        var outputElement = document.getElementById('output1');\r\n        var reader = new FileReader();\r\n        /* ���������� � ����� ��� ����� */\r\n        var fileName = file.name.replace(/\\\\/g, \"/\").split('/').pop();\r\n        /* ������ ���������� ����� */\r\n        var fileExtension = fileName && fileName.split(\".\").pop();\r\n        outputElement.innerHTML = 'Name of file: ' + fileName;\r\n        /* ������������� ���������� ������� onload. ��� ��������� �� ��������� ������ ����� */\r\n        reader.onload = function (e) {\r\n            /* e.target.textContent/reader.result �������� �� ���������� ����� */\r\n            var fileContent = reader.result;\r\n            var size = 0;\r\n            switch (fileExtension) {\r\n                case \"txt\":\r\n                    ReadTXTFile(fileContent, model);\r\n                    break;\r\n                case \"stl\":\r\n                    ReadSTLFile(fileContent, model);\r\n                    break;\r\n                default:\r\n                    alert(\"ERROR: this file extension is not supported!\");\r\n                    return;\r\n            }\r\n            /// ��� ��� ���� ����� ������������ ��� ����� ��������\r\n            //parseInTriangles(vertval);\r\n            //colorBinding(max, min);\r\n            callback(model);\r\n        };\r\n        /* �������� ������ ���������� ����� */\r\n        if (fileExtension == \"txt\")\r\n            reader.readAsText(file);\r\n        if (fileExtension == \"stl\")\r\n            reader.readAsArrayBuffer(file);\r\n    };\r\n}\r\nfunction colorBinding(max, min) {\r\n    var colorLength = max - min;\r\n    var colorStep = colorLength / 9;\r\n    // lbl1.textContent = (max).toExponential(5);\r\n    // lbl2.textContent = (max - colorStep).toExponential(5);\r\n    // lbl3.textContent = (max - colorStep * 2).toExponential(5);\r\n    // lbl4.textContent = (max - colorStep * 3).toExponential(5);\r\n    // lbl5.textContent = (max - colorStep * 4).toExponential(5);\r\n    // lbl6.textContent = (max - colorStep * 5).toExponential(5);\r\n    // lbl7.textContent = (max - colorStep * 6).toExponential(5);\r\n    // lbl8.textContent = (max - colorStep * 7).toExponential(5);\r\n    // lbl9.textContent = (max - colorStep * 8).toExponential(5);\r\n    // lbl10.textContent = (max - colorStep * 9).toExponential(5);\r\n}\r\n//  function initialShaders() {\r\n//      /* �������� ���� ��������� � ��� ����������� ������� */\r\n//      const vertexShader = getShader(gl, gl.VERTEX_SHADER, myVertexShader);\r\n//      const fragmentShader1 = getShader(gl, gl.FRAGMENT_SHADER, myFragmentShader1);\r\n//      const fragmentShader2 = getShader(gl, gl.FRAGMENT_SHADER, myFragmentShader2);\r\n//      const fragmentShader3 = getShader(gl, gl.FRAGMENT_SHADER, myFragmentShader3);\r\n//      /* ������ ����� �������� ShaderProgram */\r\n//      shaderProgram = gl.createProgram();\r\n//      /* ������ ����� �������� ShaderProgram2 */\r\n//      shaderProgram2 = gl.createProgram();\r\n//      shaderProgram3 = gl.createProgram(); // --------------------------------------\r\n//      /* ����������� � ���� ������� */\r\n//      gl.attachShader(shaderProgram, vertexShader);\r\n//      gl.attachShader(shaderProgram, fragmentShader1);\r\n//      /* ����������� � ���� ������� */\r\n//      gl.attachShader(shaderProgram2, vertexShader);\r\n//      gl.attachShader(shaderProgram2, fragmentShader2);\r\n//      //---------------------------------------------------\r\n//      // Attach a vertex shader\r\n//      gl.attachShader(shaderProgram3, vertexShader);\r\n//      // Attach a fragment shader\r\n//      gl.attachShader(shaderProgram3, fragmentShader3);\r\n//      //---------------------------------------------------\r\n//      /* ��������� ����� � ���������� webGl */\r\n//      gl.linkProgram(shaderProgram);\r\n//      /* ��������� ����� � ���������� webGl */\r\n//      gl.linkProgram(shaderProgram2);\r\n//      //-------------------------------------------------------\r\n//      // Link both the programs\r\n//      gl.linkProgram(shaderProgram3);\r\n//      //--------------------------------------------------------\r\n//      /* �������� �� ���������� ��������� */\r\n//      if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS))\r\n//          alert(\"SHADERPROGRAM: Could not initialise shaders!\");\r\n//      if (!gl.getProgramParameter(shaderProgram2, gl.LINK_STATUS))\r\n//          alert(\"SHADERPROGRAM2: Could not initialise shaders!\");\r\n//      if (!gl.getProgramParameter(shaderProgram3, gl.LINK_STATUS))\r\n//          alert(\"SHADERPROGRAM3: Could not initialise shaders!\");\r\n//      gl.useProgram(shaderProgram);\r\n//      /* ��������� �������� ���������(�������� ����� �� ���-��� � �_�������), ��� ���������� ����� ���������� � ������ ���������� ������ */\r\n//      shaderProgram.a_vertexPosition = gl.getAttribLocation(shaderProgram, \"a_VertexPosition\");\r\n//      /* ���������� ������������ ������ ����������-�������� a_vertexPosition */\r\n//      gl.enableVertexAttribArray(shaderProgram.a_vertexPosition);\r\n//      shaderProgram.a_TextureCoords = gl.getAttribLocation(shaderProgram, \"a_TextureCoords\");\r\n//      gl.enableVertexAttribArray(shaderProgram.a_TextureCoords);\r\n//      gl.enableVertexAttribArray(shaderProgram.a_TextureCoords + 1);\r\n//      gl.enableVertexAttribArray(shaderProgram.a_TextureCoords + 2);\r\n//      shaderProgram.a_localNumbers = gl.getAttribLocation(shaderProgram, \"a_localNumbers\");\r\n//      gl.enableVertexAttribArray(shaderProgram.a_localNumbers);\r\n//      shaderProgram.a_Normals = gl.getAttribLocation(shaderProgram, \"a_Normals\");\r\n//      gl.enableVertexAttribArray(shaderProgram.a_Normals);\r\n//      shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, \"uPMatrix\");\r\n//      shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, \"uMVMatrix\");\r\n//      gl.useProgram(shaderProgram2);\r\n//      shaderProgram2.a_vertexPosition = gl.getAttribLocation(shaderProgram2, \"a_VertexPosition\");\r\n//      gl.enableVertexAttribArray(shaderProgram2.a_vertexPosition);\r\n//      shaderProgram2.a_TextureCoords = gl.getAttribLocation(shaderProgram2, \"a_TextureCoords\");\r\n//      gl.enableVertexAttribArray(shaderProgram2.a_TextureCoords);\r\n//      gl.enableVertexAttribArray(shaderProgram2.a_TextureCoords + 1);\r\n//      gl.enableVertexAttribArray(shaderProgram2.a_TextureCoords + 2);\r\n//      shaderProgram2.a_Normals = gl.getAttribLocation(shaderProgram2, \"a_Normals\");\r\n//      gl.enableVertexAttribArray(shaderProgram2.a_Normals);\r\n//      shaderProgram2.normal_Sampler = gl.getUniformLocation(shaderProgram2, \"normal_Sampler\");\r\n//      shaderProgram2.color_Sampler = gl.getUniformLocation(shaderProgram2, \"color_Sampler\");\r\n//      shaderProgram2.grad_Sampler = gl.getUniformLocation(shaderProgram2, \"grad_Sampler\");\r\n//      shaderProgram2.pMatrixUniform = gl.getUniformLocation(shaderProgram2, \"uPMatrix\");\r\n//      shaderProgram2.mvMatrixUniform = gl.getUniformLocation(shaderProgram2, \"uMVMatrix\");\r\n//      shaderProgram2.canvasSize = gl.getUniformLocation(shaderProgram2, \"canvasSize\");\r\n//      shaderProgram2.countOfLines = gl.getUniformLocation(shaderProgram2, \"countOfLines\");\r\n//      shaderProgram2.thickness = gl.getUniformLocation(shaderProgram2, \"thickness\");\r\n//      // Use the combined shader program object\r\n//      gl.useProgram(shaderProgram3);\r\n//      /*======= Associating shaders to buffer objects ======*/\r\n//      shaderProgram3.a_vertexPosition = gl.getAttribLocation(shaderProgram3, \"a_VertexPosition\");\r\n//      gl.enableVertexAttribArray(shaderProgram3.a_vertexPosition);\r\n//      shaderProgram3.pMatrixUniform = gl.getUniformLocation(shaderProgram3, \"uPMatrix\");\r\n//      shaderProgram3.mvMatrixUniform = gl.getUniformLocation(shaderProgram3, \"uMVMatrix\");\r\n//      shaderProgram3.a_TextureCoords = gl.getAttribLocation(shaderProgram3, \"a_TextureCoords\");\r\n//      gl.enableVertexAttribArray(shaderProgram3.a_TextureCoords);\r\n//      gl.enableVertexAttribArray(shaderProgram3.a_TextureCoords + 1);\r\n//      gl.enableVertexAttribArray(shaderProgram3.a_TextureCoords + 2);\r\n//      shaderProgram3.a_Normals = gl.getAttribLocation(shaderProgram3, \"a_Normals\");\r\n//      gl.enableVertexAttribArray(shaderProgram3.a_Normals);\r\n//      // Get the attribute location\r\n//      //shaderProgram3.coordinates = gl.getAttribLocation(shaderProgram3, \"coordinates\");\r\n//      //// Point an attribute to the currently bound VBO\r\n//      //gl.vertexAttribPointer(shaderProgram3.coordinates, 3, gl.FLOAT, false, 0, 0);\r\n//      //// Enable the attribute\r\n//      //gl.enableVertexAttribArray(shaderProgram3.coordinates);\r\n//  }\r\n// function setMatrixUniforms(h) {\r\n//     if (h == 1) {\r\n//         gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);\r\n//         gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);\r\n//     }\r\n//     if (h == 2) {\r\n//         gl.uniformMatrix4fv(shaderProgram2.pMatrixUniform, false, pMatrix);\r\n//         gl.uniformMatrix4fv(shaderProgram2.mvMatrixUniform, false, mvMatrix);\r\n//     }\r\n//     if (h == 3) {\r\n//         gl.uniformMatrix4fv(shaderProgram3.pMatrixUniform, false, pMatrix);\r\n//         gl.uniformMatrix4fv(shaderProgram3.mvMatrixUniform, false, mvMatrix);\r\n//     }\r\n// }\r\n// function initialBuffers(vertval, normals) {\r\n//     gl.useProgram(shaderProgram);\r\n//     /* �������� ��������� ������� */\r\n//     triangleVertexValueBuffer = gl.createBuffer();\r\n//     /* ������������� ��� ��������� �������, ������ ��� ��������, array_buffer - ����� � ����� � �������� */\r\n//     gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexValueBuffer);\r\n//     /* �������� ��������� � ����� � ��� ��������� (� ��������� ������), ������ � �.�. ����� ���������� 1 ��� � ���-�� �����-��� */\r\n//     gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertval), gl.STATIC_DRAW);\r\n//     /* �������� ��������� ������� */\r\n//     normalsBuffer = gl.createBuffer();\r\n//     /* ������������� ��� ��������� �������, ������ ��� ��������, array_buffer - ����� � ����� � �������� */\r\n//     gl.bindBuffer(gl.ARRAY_BUFFER, normalsBuffer);\r\n//     /* �������� ��������� � ����� � ��� ��������� (� ��������� ������), ������ � �.�. ����� ���������� 1 ��� � ���-�� �����-��� */\r\n//     gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);\r\n//     gl.useProgram(shaderProgram3);\r\n//     // Create an empty buffer object\r\n//     pointsBuffer = gl.createBuffer();\r\n//     // Bind appropriate array buffer to it\r\n//     gl.bindBuffer(gl.ARRAY_BUFFER, pointsBuffer);\r\n//     // Pass the vertex data to the buffer\r\n//     gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(points), gl.STATIC_DRAW);\r\n// }\r\n// function initialColor(color) {\r\n//     var k = 0, l = 255;\r\n//     for (var i = 0; i < 3 * 512; i += 3) {\r\n//         if (k <= 255) {\r\n//             color[i] = 255;\r\n//             color[i + 1] = k;\r\n//             k++;\r\n//         }\r\n//         else {\r\n//             color[i] = l;\r\n//             color[i + 1] = 255;\r\n//             l--;\r\n//         }\r\n//         color[i + 2] = 0;\r\n//     }\r\n//     console.log(color);\r\n//     /* ����� ���� ��� �������� ����� */\r\n//     document.getElementById('col1').style.backgroundColor = 'rgb(' + color[0] + ', ' + color[1] + ', ' + color[2] + ')';\r\n//     document.getElementById('col2').style.backgroundColor = 'rgb(' + color[171] + ', ' + color[172] + ', ' + color[173] + ')';\r\n//     document.getElementById('col3').style.backgroundColor = 'rgb(' + color[339] + ', ' + color[340] + ', ' + color[341] + ')';\r\n//     document.getElementById('col4').style.backgroundColor = 'rgb(' + color[510] + ', ' + color[511] + ', ' + color[512] + ')';\r\n//     document.getElementById('col5').style.backgroundColor = 'rgb(' + color[681] + ', ' + color[682] + ', ' + color[683] + ')';\r\n//     document.getElementById('col6').style.backgroundColor = 'rgb(' + color[852] + ', ' + color[853] + ', ' + color[854] + ')';\r\n//     document.getElementById('col7').style.backgroundColor = 'rgb(' + color[1023] + ', ' + color[1024] + ', ' + color[1025] + ')';\r\n//     document.getElementById('col8').style.backgroundColor = 'rgb(' + color[1191] + ', ' + color[1192] + ', ' + color[1193] + ')';\r\n//     document.getElementById('col9').style.backgroundColor = 'rgb(' + color[1362] + ', ' + color[1363] + ', ' + color[1364] + ')';\r\n//     document.getElementById('col10').style.backgroundColor = 'rgb(' + color[1533] + ', ' + color[1534] + ', ' + color[1535] + ')';\r\n// }\r\n// function initialFramebuffer() {\r\n//     colorTexture = gl.createTexture();\r\n//     gl.bindTexture(gl.TEXTURE_2D, colorTexture);\r\n//     /* ���������� ������ � ������ ������ 0 */\r\n//     gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.viewportWidth, gl.viewportHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\r\n//     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n//     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n//     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n//     normalTexture = gl.createTexture();\r\n//     gl.bindTexture(gl.TEXTURE_2D, normalTexture);\r\n//     /* ���������� ������ � ������ ������ 0 */\r\n//     gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.viewportWidth, gl.viewportHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\r\n//     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n//     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n//     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n//     const depthTexture = gl.createTexture();\r\n//     gl.bindTexture(gl.TEXTURE_2D, depthTexture);\r\n//     gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT, gl.viewportWidth, gl.viewportHeight, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_SHORT, null);\r\n//     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n//     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n//     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n//     fb = gl.createFramebuffer();\r\n//     gl.bindFramebuffer(gl.FRAMEBUFFER, fb);\r\n//     gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);\r\n//     gl.framebufferTexture2D(gl.FRAMEBUFFER, ext.COLOR_ATTACHMENT0_WEBGL, gl.TEXTURE_2D, colorTexture, 0);\r\n//     gl.framebufferTexture2D(gl.FRAMEBUFFER, ext.COLOR_ATTACHMENT1_WEBGL, gl.TEXTURE_2D, normalTexture, 0);\r\n//     gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture, 0);\r\n//     ext.drawBuffersWEBGL([\r\n//         ext.COLOR_ATTACHMENT0_WEBGL, /* gl_FragData[0] */\r\n//         ext.COLOR_ATTACHMENT1_WEBGL  /* gl_FragData[1] */\r\n//     ]);\r\n// }\r\n// function initialGradient(){\r\n//     gl.useProgram(shaderProgram2);\r\n//     gradTexture = gl.createTexture();\r\n//     /* ���������� ������ � ������ ������ 0 */\r\n//     var color = new Uint8Array(3 * 512);\r\n//     initialColor(color);\r\n//     gl.activeTexture(gl.TEXTURE2);\r\n//     gl.bindTexture(gl.TEXTURE_2D, gradTexture);\r\n//     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n//     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n//     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n//     gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 512, 1, 0, gl.RGB, gl.UNSIGNED_BYTE, color);\r\n//     gl.uniform1i(shaderProgram2.grad_Sampler, 2);\r\n// }\r\n// function run() {\r\n//     if(pass != 3) {\r\n//         /* �������� ���� ���� - ����� */\r\n//         gl.clearColor(1.0, 1.0, 1.0, 1.0);\r\n//         /* ������� ������ ������� */\r\n//         gl.clearDepth(1.0);\r\n//         /* ��������� ������ �������(z-buffer) */\r\n//         gl.enable(gl.DEPTH_TEST);\r\n//         // Near things obscure far things\r\n//         gl.depthFunc(gl.LEQUAL);\r\n//         /* ���c��� �� ������ �������� � ������� */\r\n//         gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);}\r\n//     /* ��������� ������� ��������� (���������� ������ ������� ���� � ������ � �������, ������ �� �������) */\r\n//     gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);\r\n//     mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 1000.0, pMatrix);\r\n//     /* �������������� ��������-������� ������� � ���������, ������������ ��������� ����� ����� */\r\n//     mat4.identity(mvMatrix);\r\n//     mat4.translate(mvMatrix, [0.0, 0.0, -7.0]);\r\n//     drawScene();\r\n// }\r\n// function drawScene() {\r\n//     pushMatrix();\r\n//     mat4.translate(mvMatrix, [0.0, 0.0, tmp]);\r\n//     mat4.rotate(mvMatrix, currentAngle[0], [1.0, 0.0, 0.0]); /* ��� X */\r\n//     mat4.rotate(mvMatrix, currentAngle[1], [0.0, 1.0, 0.0]); /* ��� Y */\r\n//     gl.activeTexture(gl.TEXTURE0);\r\n//     gl.bindTexture(gl.TEXTURE_2D, colorTexture);\r\n//     gl.activeTexture(gl.TEXTURE1);\r\n//     gl.bindTexture(gl.TEXTURE_2D, normalTexture);\r\n//     if (pass == 1) {\r\n//         gl.useProgram(shaderProgram);\r\n//         gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexValueBuffer);\r\n//         /* ������������� ��������� �� ������ �� ������ ������ */\r\n//         /* ���� ���������, ������� ������������ � ������� ������(gl.ARRAY_BUFFER(triangleVertexPositionBuffer)->a_vertexPosition) */\r\n//         /*  ����� �������� ��� ������ �������, ��� ��������, ��� (�� ���� ���������������� ���������), ��������� ������� � ������) */\r\n//         gl.vertexAttribPointer(shaderProgram.a_vertexPosition, 3, gl.FLOAT, false, 4 * 14, 0);\r\n//         gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexValueBuffer);\r\n//         gl.vertexAttribPointer(shaderProgram.a_TextureCoords, 3, gl.FLOAT, false, 4 * 14, 4 * 3);\r\n//         gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexValueBuffer);\r\n//         gl.vertexAttribPointer(shaderProgram.a_TextureCoords + 1, 3, gl.FLOAT, false, 4 * 14, 4 * 6);\r\n//         gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexValueBuffer);\r\n//         gl.vertexAttribPointer(shaderProgram.a_TextureCoords + 2, 3, gl.FLOAT, false, 4 * 14, 4 * 9);\r\n//         gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexValueBuffer);\r\n//         gl.vertexAttribPointer(shaderProgram.a_localNumbers, 2, gl.FLOAT, false, 4 * 14, 4 * 12);\r\n//         gl.bindBuffer(gl.ARRAY_BUFFER, normalsBuffer);\r\n//         gl.vertexAttribPointer(shaderProgram.a_Normals, 3, gl.FLOAT, false, 4 * 3, 0);\r\n//         setMatrixUniforms(1);\r\n//         //   shaderProgram.u = gl.getUniformLocation(shaderProgram, \"u\");\r\n//         // gl.uniform1f(shaderProgram.u, 0);\r\n//         //  console.log(u);\r\n//     }\r\n//     if(pass == 2) {\r\n//         gl.useProgram(shaderProgram2);\r\n//         gl.uniform1i(shaderProgram2.color_Sampler, 0);\r\n//         gl.uniform1i(shaderProgram2.normal_Sampler, 1);\r\n//         gl.uniform2f(shaderProgram2.canvasSize, canvas.width, canvas.height);\r\n//         gl.uniform1i(shaderProgram2.countOfLines, ln);\r\n//         gl.uniform1i(shaderProgram2.thickness, thick);\r\n//         gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexValueBuffer);\r\n//         gl.vertexAttribPointer(shaderProgram2.a_vertexPosition, 3, gl.FLOAT, false, 4 * 14, 0);\r\n//         // gl.uniform1f(u);\r\n//         /* gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexValueBuffer);\r\n//         gl.vertexAttribPointer(shaderProgram2.a_TextureCoords, 3, gl.FLOAT, false, 4 * 14, 4 * 3);\r\n//         gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexValueBuffer);\r\n//         gl.vertexAttribPointer(shaderProgram2.a_TextureCoords + 1, 3, gl.FLOAT, false, 4 * 14, 4 * 6);\r\n//         gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexValueBuffer);\r\n//         gl.vertexAttribPointer(shaderProgram2.a_TextureCoords + 2, 3, gl.FLOAT, false, 4 * 14, 4 * 9);\r\n//            gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexValueBuffer);\r\n//         gl.vertexAttribPointer(shaderProgram2.a_localNumbers, 2, gl.FLOAT, false, 4 * 14, 4 * 12);\r\n//           gl.bindBuffer(gl.ARRAY_BUFFER, normalsBuffer);\r\n//         gl.vertexAttribPointer(shaderProgram2.a_Normals, 3, gl.FLOAT, false, 4 * 3, 0);*/\r\n//         setMatrixUniforms(2);\r\n//     }\r\n//     if(pass != 3)\r\n//         /* ������� ��������� ��������� ������ (��� ���������, ������ ������ �������, ���������� ������) */\r\n//         gl.drawArrays(gl.TRIANGLES, 0, size * 3);\r\n//     if(pass == 3) {\r\n//         gl.useProgram(shaderProgram3);\r\n//         gl.bindBuffer(gl.ARRAY_BUFFER, pointsBuffer);\r\n//         gl.vertexAttribPointer(shaderProgram3.a_vertexPosition, 3, gl.FLOAT, false, 4 * 3, 0);\r\n//         gl.bindBuffer(gl.ARRAY_BUFFER, pointsBuffer);\r\n//         gl.vertexAttribPointer(shaderProgram.a_TextureCoords, 3, gl.FLOAT, false, 4 * 3, 0);\r\n//         gl.bindBuffer(gl.ARRAY_BUFFER, pointsBuffer);\r\n//         gl.vertexAttribPointer(shaderProgram.a_TextureCoords + 1, 3, gl.FLOAT, false, 4 * 3, 0);\r\n//         gl.bindBuffer(gl.ARRAY_BUFFER, pointsBuffer);\r\n//         gl.vertexAttribPointer(shaderProgram.a_TextureCoords + 2, 3, gl.FLOAT, false, 4 * 3, 0);\r\n//         gl.bindBuffer(gl.ARRAY_BUFFER, pointsBuffer);\r\n//         gl.vertexAttribPointer(shaderProgram.a_localNumbers, 2, gl.FLOAT, false, 4 * 3, 0);\r\n//         gl.bindBuffer(gl.ARRAY_BUFFER, pointsBuffer);\r\n//         gl.vertexAttribPointer(shaderProgram.a_Normals, 3, gl.FLOAT, false, 4 * 3, 0);\r\n//         setMatrixUniforms(3);\r\n//         gl.drawArrays(gl.LINES, 0, points.length / 3);\r\n//     }\r\n//     popMatrix();\r\n// }\r\n//var mvMatrixStack = [];\r\n// function pushMatrix() {\r\n//     var copy = mat4.create();\r\n//     mat4.set(mvMatrix, copy);\r\n//     mvMatrixStack.push(copy);\r\n// }\r\n// function popMatrix() {\r\n//     if (mvMatrixStack.length == 0)\r\n//         throw \"Invalid popMatrix!\";\r\n//     mvMatrix = mvMatrixStack.pop();\r\n// }\r\n// function initialEventHandlers() {\r\n//     /* ����������, �����������, ���������� ��� ������ ��� ��� (� ����������� �� ������� ������) */\r\n//     var dragging = false;\r\n//     /* ���������� ��������� ������� ��������� ���� */\r\n//     var lastX = -1, lastY = -1;\r\n//     /* ���������� ������� - ������� ������ ���� */\r\n//     canvas.onmousedown = function (ev) {\r\n//         /* �������� ������� x � y �������� canvas */\r\n//         var x = ev.clientX, y = ev.clientY;\r\n//         /* ������ ����������, ���� ��������� � �������� �������� <canvas>, getBoundingClientRect() ���������� ���������� �������� */\r\n//         var rect = ev.target.getBoundingClientRect();\r\n//         if (rect.left <= x && x < rect.right && rect.top <= y && y < rect.bottom) {\r\n//             lastX = x; lastY = y;\r\n//             dragging = true;\r\n//         }\r\n//     };\r\n//     /* ���������� ������� - �������� ������ ���� */\r\n//     canvas.onmouseup = function (ev) { dragging = false; };\r\n//     /* ���������� ������� - ����������� ��������� ���� */\r\n//     canvas.onmousemove = function (ev) {\r\n//         var x = ev.clientX, y = ev.clientY;\r\n//         if (dragging) {\r\n//             /* �������� �������� �������� */\r\n//             var factor = 100 / canvas.height / 10;\r\n//             var dx = factor * (x - lastX);\r\n//             var dy = factor * (y - lastY);\r\n//             /* ����������� ���� �������� �� ��� X �� -90 �� 90 �������� */\r\n//             currentAngle[0] = Math.max(Math.min(currentAngle[0] + dy, 90.0), -90.0);\r\n//             currentAngle[1] = currentAngle[1] + dx;\r\n//         }\r\n//         lastX = x, lastY = y;\r\n//     };\r\n// }\r\n// function initialMouseWheel(t) {\r\n//     /* ���������� ������� - ��������������� � ������� ������� */\r\n//     document.onmousewheel = function (ev) {\r\n//         var delta = 0;\r\n//         if (!event) event = window.event; /* ������� IE */\r\n//         /* ��������� ������ \"���������\", ������ = 120 �����, - 120 ���� */\r\n//         if (event.wheelDelta) {\r\n//             /* IE, Opera, safari, chrome - ��������� ������ ����� 120 */\r\n//             delta = event.wheelDelta / 120;\r\n//         } else if (event.detail) {\r\n//             /* Mozilla, ��������� ������ ����� 3 */\r\n//             delta = -event.detail / 3;\r\n//         }\r\n//         if (delta) {\r\n//             /* �������� ������� ������� - ������������� ������ ��������� */\r\n//             if (event.preventDefault)\r\n//                 event.preventDefault();\r\n//             /* ��� IE, ������� � preventDefault() �� ����� */\r\n//             event.returnValue = false;\r\n//             /* ���� ������ ������ 0, �� ������ ������ �����, ����� ���� */\r\n//             if (delta > 0) {\r\n//                 //if (t <= 12) {\r\n//                 tmp += 0.2;\r\n//                 t++;\r\n//                 // }\r\n//             }\r\n//             else {\r\n//                 tmp += -0.2;\r\n//                 t--;\r\n//             }\r\n//         }\r\n//     };\r\n// }\r\n// function onChangeTrackBar() {\r\n//     document.getElementById('trackBarValue').innerHTML = document.getElementById('trackbar').value;\r\n//     ln = document.getElementById('trackbar').value;\r\n//     rendering();\r\n// }\r\n// function onChangeThicknessTrackBar() {\r\n//     document.getElementById('thicknessTrackBarValue').innerHTML = size;\r\n//     thick = document.getElementById('th_trackbar').value;\r\n//     img = document.getElementById(\"pic\");\r\n//     img.width = 1.5 * thick;\r\n//     rendering();\r\n// }\r\n// function rendering(then) {\r\n//     let frameCount = function _fc(then){\r\n//         let now = performance.now();\r\n//         let duration = now - then;\r\n//         if(duration < 1000){\r\n//             _fc.counter++;\r\n//         } else {\r\n//             _fc.fps = _fc.counter;\r\n//             _fc.counter = 0;\r\n//             then = now;\r\n//             document.getElementById('count').innerHTML = _fc.fps;\r\n//         }\r\n//         requestAnimationFrame(() => frameCount(then));\r\n//     }\r\n//     frameCount.counter = 0;\r\n//     frameCount.fps = 0;\r\n//     if (!gl) return;\r\n//     gl.bindFramebuffer(gl.FRAMEBUFFER, fb);\r\n//     pass = 1;\r\n//     run();\r\n//     gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n//     pass = 2;\r\n//     run();\r\n//     //--------------------------------------------------------\r\n//     pass = 3;\r\n//     run();\r\n//     //--------------------------------------------------------\r\n//     frameCount(performance.now())\r\n//     requestAnimationFrame(rendering);\r\n// }\r\n// function InitDefaultValues() : boolean {\r\n// /* ��������� ������� ��� ��������� �������� */\r\n// canvas = document.getElementById(\"canvasWebGL\") as HTMLCanvasElement;\r\n// if (!canvas) {\r\n//     alert(\"ERROR: can't get canvasElement!\");\r\n//     return false;\r\n// }\r\n// /* ������� ��������x �������� */\r\n// currentAngle = [0.0, 0.0]; // [��� X, ��� Y] �������\r\n// let trackBarValue = document.getElementById('trackBarValue');\r\n// if (trackBarValue)\r\n//     trackBarValue.innerHTML = \"0\";\r\n// else\r\n//     alert(\"ERROR: trackBarValue is not found!\");\r\n// let thicknessTrackBarValue = document.getElementById('thicknessTrackBarValue');\r\n// if (thicknessTrackBarValue)\r\n//     thicknessTrackBarValue.innerHTML = \"1\";\r\n// else\r\n//     alert(\"ERROR: thicknessTrackBarValue is not found!\");\r\n// let countOfLines = document.getElementById('countOfLines');\r\n// if (countOfLines)\r\n//     countOfLines.innerHTML = \"0\";\r\n// else\r\n//     alert(\"ERROR: countOfLines is not found!\");\r\n// /* �������� ��������� ���������� WebGL */\r\n// let drawBuffersExtension = gl.getExtension('WEBGL_draw_buffers') || gl.getExtension(\"GL_EXT_draw_buffers\") || gl.getExtension(\"EXT_draw_buffers\");\r\n// let depthTextureExtension = gl.getExtension('WEBGL_depth_texture');\r\n// if (!drawBuffersExtension || !depthTextureExtension) {\r\n//     alert(\"ERROR: Can't get extension! \");\r\n//     return false;\r\n// }\r\n// return true;\r\n// }\r\nfunction mainWebGL() {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var text, vertval, normals, model, res;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    model = new Model();\r\n                    return [4 /*yield*/, new Promise(function (resolve) { return InputData(resolve, model); })];\r\n                case 1:\r\n                    res = _a.sent();\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    });\r\n}\r\n\n\n//# sourceURL=webpack:///./src/index.ts?");

/***/ })

/******/ });